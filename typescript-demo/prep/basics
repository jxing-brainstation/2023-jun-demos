//== BASICS ==//

/**
 * (1) x is a string, b/c weâ€™ve initialized it
 * TS performs inference during initialization. X can be any string!
 */
let x = "hello world";

/**
 * (2) reassignment is fine because it's a let declaration
 */
x = "hello mars";

/**
 * (3) but if we try to change type, you get the error "Type 'number' is not assignable to type 'string'"
 *  a type equivalence check
 */
x = 42; // ðŸš¨ ERROR

/**
 * (4) let's look at const. The type is literally 'hello world'
 * this is a string literal type. Y can only be this specific string
 */
const y = "hello world";

/**
 * This is called a 'string literal type'. y can never be reassigned since it's a const,
 * so we can regard it as only ever holding a value that's literally the string 'hello world'
 * and no other possible value
 */

/**
 * (5) sometimes we need to declare a variable w/o initializing it
 */
let z; // right here Z is of type "any" - the most flexible type
z = 41;
z = "abc"; // (6) oh no! This isn't good to do, but it's still valid. see next step on how 

/**
 * If we look at the type of z, it's `any`. This is the most flexible type
 * in TypeScript (think of it like a JavaScript `let`)
 */

/**
 * (7) we could improve this situation by providing a type annotation
 * when we declare our variable
 */
let zz: number;
zz = 41;
zz = "abc"; // ðŸš¨ ERROR Type 'string' is not assignable to type 'number'. Now we know there an issue because we provided the type annotation during initialization.

//== SIMPLE ARRAYS ==//

/**
 * (8) simple array types can be expressed using []
 */
// let aa = []; this does not default to an array of anys (it's a complicated answer why)
let aa: number[] = []; // aa is an array of numbers. the type annotation here is number[]
aa.push(33);
aa.push("abc"); // ðŸš¨ ERROR: Argument of type 'string' is not assignable to parameter of type 'number'.

/**
 * (9) we can even define a tuple, which has a fixed length. it's like a fixed length array
 *  always provide an explicity type annotatio when you initialize tuples!!
 */
let bb: [number, string, string, number] = [
  123,
  "Fake Street",
  "Nowhere, USA",
  10110
];
// useful when you need to return more than one thing from a function

bb = [1, 2, 3]; // ðŸš¨ ERROR: Type 'number' is not assignable to type 'string'.
bb = [1,"str1", "str2", 4, 10] // ðŸš¨ ERROR: can't just add one more element. the target only allows 4

/**
 * (10) Tuple values often require type annotations (  : [number, number] )
 */
const xx = [32, 31]; // number[];
const xxx : number[] = [32,31]; // this enforces that it must be an array of numbers
const yy: [number, number] = [32, 31]; // this is different from the above line because it enforces that it has to be an array of two numbers. 

//== OBJECTS ==//

/**
 * (11) object types can be expressed using {} and property names
 */
let cc: { houseNumber: number; streetName: string };
cc = {
  streetName: "Fake Street",
  houseNumber: 123
};
cc.zipcode = 11101; // ðŸš¨ ERROR: this property does not exist on the declared type
cc = {
  houseNumber: 33
};
/**
 * ðŸš¨ Property 'streetName'
 * ðŸš¨   is missing in type   '{ houseNumber: number; }'
 * ðŸš¨   but required in type '{ houseNumber: number; streetName: string; }'.
 * it thinks you're trying to change the types
 * structural type checking- looking for the right types
 */

/**
 * (12) You can use the optional operator (?) to
 * indicate that something may or may not be there
 */
let dd: { houseNumber: number; streetName?: string };
dd = {
  houseNumber: 33,
};
dd.streetName?.split(", ") //optional chaining operator. not good because you're making assumptions
dd.streetName!.split(", ") //non null assertion operator. it will throw. don't use in application code, good to use in test code. 
dd.streetName = "baltic"

// (13) if we want to re-use this type, we can create an interface. it's the shape of an object. disappears during the compile process.
interface Address {
  houseNumber: number;
  streetName?: string;
}
// type Address {
//     houseNumber: number;
//     streetName?: string;
// }
// and refer to it by name
let ee: Address = { houseNumber: 33 };
ee= dd; // could be a problem if it was a nominal type system 

//== UNION & INTERSECTION ==//

/**
 * (14) Union types is the OR
 * Sometimes we have a type that can be one of several things
 */

export interface HasPhoneNumber {
  name: string;
  phone: number;
} // this is kinda like the JS doc comment. it's not runnable- it's inert information

export interface HasEmail {
  name: string;
  email: string;
}

let contactInfo: HasEmail | HasPhoneNumber = //because we have types, it's an either or. maps cleanly to JS operators. 
  Math.random() > 0.5
    ? {
        // we can assign it to a HasPhoneNumber
        name: "Mike",
        phone: 3215551212
      }
    : {
        // or a HasEmail
        name: "Mike",
        email: "mike@example.com"
      };

contactInfo.name; // NOTE: we can only access the .name property  (the stuff HasPhoneNumber and HasEmail have in common)
contactInfo.phone; // not same to assume that there's 

// isHasEmail has to be defined in a special way
// if (isHasEmail(contactInfo)) {
//     contactInfo.email = "changed@email.com"
// }else {
//     return;
// }

/**
 * (15) Intersection types is the AND
 */
let otherContactInfo: HasEmail & HasPhoneNumber = { // this is defining an intersection type 
  // we _must_ initialize it to a shape that's asssignable to HasEmail _and_ HasPhoneNumber
  name: "Mike",
  email: "mike@example.com",
  phone: 3215551212
};

otherContactInfo.name; // NOTE: we can access anything on _either_ type
otherContactInfo.email;
otherContactInfo.phone;
const zzz: any = {} as never;

export default {};


/************ */
import { HasEmail, HasPhoneNumber } from "./1-basics";

//== FUNCTIONS ==//

// (1) function arguments and return values can have type annotations
function sendEmail(to: HasEmail): { recipient: string; body: string } {
  return {
    recipient: `${to.name} <${to.email}>`, // Mike <mike@example.com>
    body: "You're pre-qualified for a loan!"
  };
}

// (2) or the arrow-function variant
const sendTextMessage = (
  to: HasPhoneNumber
): { recipient: string; body: string } => {
  return {
    recipient: `${to.name} <${to.phone}>`,
    body: "You're pre-qualified for a loan!"
  };
};

// (3) return types can almost always be inferred, but it's good practice to always set return types on your functions
// works like assignment with an initializer
function getNameParts(contact: { name: string }) 
// this is what it would look like if you specify the return type.
// : {
//     first: string;
//     middle: string | undefined;
//     last: string;
// } 
{
  const parts = contact.name.split(/\s/g); // split @ whitespace
  if (parts.length < 2) {
    // return null; // this makes the inferred return type a bit more fuzzy
    throw new Error(`Can't calculate name parts from name "${contact.name}"`);
  }
  return {
    // first: parts[0].length <2 ? null : parts[0], //this is not good to do. the type for first will be inferred as string | null
    first: parts[0],
    middle:
      parts.length === 2
        ? undefined
        : // everything except first and last
          parts.slice(1, parts.length - 2).join(" "),
    last: parts[parts.length - 1]
  };
}

// (4) rest params work just as you'd think. Type must be array-ish
const sum = (...vals: number[]) => vals.reduce((sum, x) => sum + x, 0);
// console.log(sum(3, 4, 6)); // 13

// (5) we can even provide multiple function signatures, aka overloads
// "overload signatures"
function contactPeople(method: "email", ...people: HasEmail[]): void; //this is the function head
function contactPeople(method: "phone", ...people: HasPhoneNumber[]): void;

// "function implementation"
// TODO what does this look like when it's compiled? 
function contactPeople(
  method: "email" | "phone",
  ...people: (HasEmail | HasPhoneNumber)[]
): void {
  if (method === "email") {
    (people as HasEmail[]).forEach(sendEmail);
  } else {
    (people as HasPhoneNumber[]).forEach(sendTextMessage);
  }
}

// âœ… email works THIS IS WHERE MY MIND IS BLOWN
contactPeople("email", { name: "foo", email: "" });

// âœ… phone works
contactPeople("phone", { name: "foo", phone: 12345678 });

// ðŸš¨ mixing does not work
contactPeople("email", { name: "foo", phone: 12345678 }); // ðŸš¨ ERROR no overload matches this call
contactPeople() // the function implementation is not exposed. 

// (6) the lexical scope (this) of a function is part of its signature

function sendMessage(
  this: HasEmail & HasPhoneNumber, // needs to be the first thing in an arguments list
  preferredMethod: "phone" | "email"
) {
  if (preferredMethod === "email") {
    console.log("sendEmail");
    sendEmail(this);
  } else {
    console.log("sendTextMessage");
    sendTextMessage(this);
  }
}
const c = { name: "Mike", phone: 3215551212, email: "mike@example.com" };

function invokeSoon(cb: () => any, timeout: number) {
  setTimeout(() => cb.call(null), timeout);
}

// ðŸš¨ this is not satisfied
invokeSoon(() => sendMessage("email"), 500);

// âœ… creating a bound function is one solution
const bound = sendMessage.bind(c, "email");
invokeSoon(() => bound(), 500);

// âœ… apply works as well
const applied = sendMessage.apply(c, ["phone"])
invokeSoon(() => applied, 500);

// âœ… call works as well.. provide an example??

export default {};


/*********** */
import { HasPhoneNumber, HasEmail } from "./1-basics";

//== TYPE ALIAS ==//
/**
 * (1) Type aliases allow us to give a type a name
 */
type StringOrNumber = string | number; // a union. can't do this with an interface
let six : StringOrNumber = 6;

// // this is the ONLY time you'll see a type on the right hand side of assignment
type HasName = { name: string };

// NEW in TS 3.7: Self-referencing types! can use it recursively
type NumVal = 1 | 2 | 3 | NumVal[];
const x1 : NumVal = 3; //valid
const x2 : NumVal = 3; //invalid??
const y : NumVal = [1,2, [2, 2, [1, 3]], 3, ];  //valid


// == INTERFACE == //
/**
 * (2) Interfaces can extend from other interfaces
 */

export interface HasInternationalPhoneNumber extends HasPhoneNumber {
  countryCode: string;
}

/**
 * (3) they can also be used to describe call signatures
 */

interface ContactMessenger1 {
  (contact: HasEmail | HasPhoneNumber, message: string): void;
}

type ContactMessenger2 = (
  contact: HasEmail | HasPhoneNumber,
  message: string
) => void;

// NOTE: we don't need type annotations for contact or message
const emailer: ContactMessenger1 = (_contact, _message) => {
  /** ... */
};

const emailer2: ContactMessenger2 = (_contact, _message) => {
    /** ... */
  };

/**
 * (4) construct signatures can be described as well
 */

interface ContactConstructor {
  new (...args: any[]): HasEmail | HasPhoneNumber;
}

/**
 * (5) index signatures describe how a type will respond to property access
 */

/**
 * @example
 * {
 *    iPhone: { areaCode: 123, num: 4567890 },
 *    home:   { areaCode: 123, num: 8904567 },
 * }
 */

interface PhoneNumberDict {
  // arr[0],  foo['myProp']
  [numberName: string]: undefined | {
        areaCode?: number;
        num: number;
    };
}

const phoneDict: PhoneNumberDict = {
  office: { areaCode: 321, num: 5551212 },
  home: { areaCode: 321, num: 5550010 }, // try editing me
  fax: {num: 123091230}
};

phoneDict.cell?.num

//great way to enforce consistency for a dictionary

// at most, a type may have one string and one number index signature
// because keys for dictionaries can only be strings or numbers?

/**
 * (6) they may be used in combination with other types
 */

// interfaces are open. then can augment the existing interface throughout the entire code base 
// augment the existing PhoneNumberDict
// i.e., imported it from a library, adding stuff to it
// notice that this was already defined above
// TS does a holistic examination of the entire codebase
interface PhoneNumberDict {
  name: string; // this is not good. there's a collision
  home: {
    /**
     * (7) interfaces are "open", meaning any declarations of the
     * -   same name are merged
     */
    areaCode: number;
    num: number;
  };
  office: {
    areaCode: number;
    num: number;
  };
}

phoneDict.home;   // definitely present
phoneDict.office; // definitely present
phoneDict.mobile; // MAYBE present

// == TYPE ALIASES vs INTERFACES == //

/**
 * (7) Type aliases are initialized synchronously, but
 * -   can reference themselves
 */

type NumberVal = 1 | 2 | 3 | NumberVal[];

/**
 * (8) Interfaces are initialized lazily, so combining it
 * -   w/ a type alias allows for recursive types!
 */

type StringVal = "a" | "b" | "c" | StringArr;

let teststr : StringVal = ["a", "b", ["a"]];

// type StringArr = StringVal[];
interface StringArr {
  // arr[0]
  [k: number]: "a" | "b" | "c" | StringVal[];
}

const x: StringVal = Math.random() > 0.5 ? "b" : ["a"]; // âœ… ok!

export default {};
